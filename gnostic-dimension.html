<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Gnostic-Sphere — pareidolic glyph orbit</title>
<style>
  :root {
    --bg: #0b0b0e;
    --fg: #eaeaea;
    --teal: #00f3ff;
    --muted: #83848a;
  }
  html, body { height: 100%; margin: 0; background: radial-gradient(1200px 800px at 50% 50%, #0f0f14, var(--bg)); color: var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji"; }
  #app { position: fixed; inset: 0; overflow: hidden; }
  canvas { display: block; }
  .hud {
    position: fixed; top: 12px; right: 12px; background: rgba(12,12,16,0.6);
    border: 1px solid rgba(255,255,255,0.08); border-radius: 14px; backdrop-filter: blur(6px);
    padding: 10px 12px; font-size: 13px; line-height: 1.2; box-shadow: 0 8px 30px rgba(0,0,0,0.35);
    user-select: none;
  }
  .hud h1 { font-size: 12px; letter-spacing: .08em; text-transform: uppercase; margin: 0 0 8px; color: var(--muted); }
  .row { display: flex; align-items: center; gap: 8px; margin: 6px 0; }
  .row label { width: 110px; color: var(--muted); }
  .row input[type="range"] { width: 160px; }
  .btn {
    appearance: none; border: 1px solid rgba(255,255,255,0.14); background: rgba(255,255,255,0.04);
    padding: 6px 10px; border-radius: 10px; color: var(--fg); cursor: pointer;
    transition: transform .08s ease, background .2s ease, border-color .2s ease;
  }
  .btn:hover { background: rgba(255,255,255,0.08); }
  .btn:active { transform: translateY(1px) scale(0.99); }
  .badge {
    position: fixed; left: 12px; bottom: 12px; font-size: 12px; color: var(--muted);
    letter-spacing: .02em; opacity: .8;
  }
  .legend {
    position: fixed; left: 12px; top: 12px; font-size: 12px; color: #9ba0a6; opacity: .8;
  }
  .legend strong { color: var(--fg); }
</style>
</head>
<body>
<div id="app"></div>

<div class="legend">Gnostic-Sphere • <strong>drag</strong> = orbit • <strong>scroll</strong> = zoom</div>

<div class="hud">
  <h1>pareidolia controls</h1>
  <div class="row">
    <label for="density">glyph count</label>
    <input id="density" type="range" min="200" max="1600" step="50" value="900">
    <span id="densityVal">900</span>
  </div>
  <div class="row">
    <label for="spin">global spin</label>
    <input id="spin" type="range" min="-0.6" max="0.6" step="0.01" value="0.08">
    <span id="spinVal">0.08</span>
  </div>
  <div class="row">
    <label for="drift">micro drift</label>
    <input id="drift" type="range" min="0" max="0.008" step="0.0002" value="0.003">
    <span id="driftVal">0.0030</span>
  </div>
  <div class="row">
    <label for="momentEvery">moment (s)</label>
    <input id="momentEvery" type="range" min="3" max="18" step="1" value="7">
    <span id="momentEveryVal">7</span>
  </div>
  <div class="row">
    <button class="btn" id="trigger">trigger moment</button>
    <button class="btn" id="shuffle">shuffle glyphs</button>
  </div>
</div>

<div class="badge">gnostic pareidolia • teal glows mark “found meaning”</div>

<!-- Three.js CDN -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
<script>
(() => {
  const app = document.getElementById('app');

  // === parameters ===
  let GLYPH_COUNT = 900;
  let GLOBAL_SPIN = 0.08;            // radians/sec
  let MICRO_DRIFT = 0.003;           // max offset per tick
  let MOMENT_EVERY = 7;              // seconds
  const RADIUS = 18;                 // sphere radius
  const CHARSET = Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
  const SIGILS  = ["◉","∆","⟁","✶","✦","✧","✺","✹","☉","✸","✴","✷","✹","✺","✪","✳","✻","✽","✥"];
  const ALL_CHARS = [...CHARSET, ...SIGILS, ..."abcdefghijklmnopqrstuvwxyz0123456789".split("")];
  const WORDS = [
    "ARC","ECHO","RUNE","VOID","SEA","STAR","SEER","FATE","CODE","TEAL","KEY","MYTH",
    "SENT","GATE","DAWN","REAL","NAME","SIGN","GLYPH","RAY","WORD","WAVE","ORB","NODE"
  ];

  // === three.js setup ===
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0b0b0e, 0.04);

  const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 38);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance", preserveDrawingBuffer: false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setClearColor(0x0b0b0e, 1);
  app.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.rotateSpeed = 0.5;
  controls.zoomSpeed = 0.7;
  controls.enablePan = false;
  controls.minDistance = 14;
  controls.maxDistance = 70;

  // light ambient shimmer
  const light = new THREE.AmbientLight(0xffffff, 0.7);
  scene.add(light);

  // group for glyphs
  const sphereGroup = new THREE.Group();
  scene.add(sphereGroup);

  // util: make a glowing text sprite texture
  function makeGlyphTexture(char, color="#eaeaea", glow="#00f3ff") {
    const size = 128; // canvas size
    const cvs = document.createElement('canvas');
    cvs.width = cvs.height = size;
    const ctx = cvs.getContext('2d');
    ctx.clearRect(0,0,size,size);

    // soft outer glow (teal) for better readability at distance
    ctx.font = 'bold 84px JetBrains Mono, Menlo, Consolas, monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // teal halo
    ctx.shadowColor = glow;
    ctx.shadowBlur = 28;
    ctx.fillStyle = 'rgba(0,243,255,0.16)';
    ctx.fillText(char, size/2, size/2);

    // white core
    ctx.shadowBlur = 0;
    ctx.fillStyle = color;
    ctx.fillText(char, size/2, size/2);

    return new THREE.CanvasTexture(cvs);
  }

  // glyph factory — a THREE.Sprite with a character
  function makeGlyph(char) {
    const tex = makeGlyphTexture(char);
    tex.anisotropy = renderer.capabilities.getMaxAnisotropy?.() || 1;
    const mat = new THREE.SpriteMaterial({
      map: tex,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      opacity: 0.9
    });
    const sprite = new THREE.Sprite(mat);
    const baseScale = THREE.MathUtils.randFloat(0.6, 1.2);
    sprite.scale.set(baseScale, baseScale, baseScale);
    sprite.userData = {
      char,
      baseScale,
      seed: Math.random() * 1000,
      state: "free",          // "free" | "moment"
      origPos: new THREE.Vector3(),
      targetPos: null,
      t: 0
    };
    return sprite;
  }

  // fibonacci sphere points
  function spherePoints(n, r=RADIUS) {
    const pts = [];
    const offset = 2 / n;
    const inc = Math.PI * (3 - Math.sqrt(5));
    for (let i = 0; i < n; i++) {
      const y = ((i * offset) - 1) + (offset / 2);
      const d = Math.sqrt(1 - y * y);
      const phi = i * inc;
      const x = Math.cos(phi) * d;
      const z = Math.sin(phi) * d;
      // small random shell jitter for thickness
      const jitter = THREE.MathUtils.randFloatSpread(0.9);
      pts.push(new THREE.Vector3(x, y, z).multiplyScalar(r + jitter));
    }
    return pts;
  }

  // populate sphere
  let glyphs = [];
  function populate(count) {
    // clear old
    for (const g of glyphs) {
      g.material.map.dispose();
      g.material.dispose();
      sphereGroup.remove(g);
    }
    glyphs.length = 0;

    const pts = spherePoints(count);
    for (let i = 0; i < count; i++) {
      const ch = ALL_CHARS[Math.floor(Math.random() * ALL_CHARS.length)];
      const s = makeGlyph(ch);
      s.position.copy(pts[i]);
      s.userData.origPos.copy(pts[i]);
      glyphs.push(s);
      sphereGroup.add(s);
    }
  }

  // pareidolia moment: pick a word and temporarily assemble it facing the camera
  function triggerMoment(word = null) {
    if (glyphs.length < 10) return;
    const W = word || WORDS[Math.floor(Math.random() * WORDS.length)];
    const letters = W.split("");

    // choose candidates (free glyphs) closest to camera-forward region
    const free = glyphs.filter(g => g.userData.state === "free");

    // If not enough, just bail.
    if (free.length < letters.length) return;

    // Pick nearest to a random axis facing camera
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);

    // project dot to prioritise near-facing sprites
    free.sort((a,b) => b.position.clone().normalize().dot(forward) - a.position.clone().normalize().dot(forward));

    // take the top N
    const chosen = free.slice(0, letters.length);

    // assign letters & glow
    chosen.forEach((g, i) => {
      const char = letters[i];
      g.userData.state = "moment";
      g.userData.t = 0;
      // swap texture with teal glow emphasis
      const tealTex = makeGlyphTexture(char, "#eaffff", "#00f3ff");
      g.material.map?.dispose();
      g.material.map = tealTex;
      g.material.needsUpdate = true;
      g.material.opacity = 1.0;
      g.userData.char = char;
    });

    // build positions on a plane in front of camera, slight curve (arc)
    const planeCenter = forward.clone().multiplyScalar(RADIUS * 0.92);
    const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();
    const up = new THREE.Vector3().crossVectors(right, forward).normalize();

    const letterGap = 1.1;
    const totalWidth = (letters.length - 1) * letterGap;
    const arc = 0.15; // small arc curvature

    chosen.forEach((g, i) => {
      const x = (i * letterGap) - totalWidth/2;
      const y = Math.sin((i / Math.max(1,(letters.length-1))) * Math.PI) * arc;
      const target = new THREE.Vector3()
        .addScaledVector(right, x)
        .addScaledVector(up, y)
        .add(planeCenter);
      g.userData.targetPos = target;
    });

    // after a short hold, release them back
    setTimeout(() => {
      chosen.forEach(g => {
        g.userData.state = "returning";
        g.userData.t = 0;
      });
      // restore texture a moment later to standard glyphs
      setTimeout(() => {
        chosen.forEach(g => {
          // recycle to a random glyph (keeps it alive/varied)
          const newChar = ALL_CHARS[Math.floor(Math.random() * ALL_CHARS.length)];
          const tex = makeGlyphTexture(newChar);
          g.material.map?.dispose();
          g.material.map = tex;
          g.material.opacity = 0.9;
          g.material.needsUpdate = true;
          g.userData.char = newChar;
        });
      }, 550);
    }, 1200);
  }

  // micro drift using time + per-sprite seed
  function driftOffset(g, t) {
    const k = 0.7;
    const s = g.userData.seed;
    const dx = (Math.sin(t * 0.9 + s) + Math.sin(t * 0.5 + s*1.7)) * 0.5;
    const dy = (Math.cos(t * 0.8 + s*0.8) + Math.sin(t * 0.6 + s*1.3)) * 0.5;
    const dz = (Math.sin(t * 0.7 + s*1.1) + Math.cos(t * 0.4 + s*0.6)) * 0.5;
    return new THREE.Vector3(dx, dy, dz).multiplyScalar(MICRO_DRIFT * k * RADIUS);
  }

  // animate
  let last = performance.now() / 1000;
  let sinceMoment = 0;

  function tick() {
    const now = performance.now() / 1000;
    const dt = Math.min(0.04, now - last);
    last = now;
    sinceMoment += dt;

    // global spin
    const spin = GLOBAL_SPIN * dt;
    sphereGroup.rotateY(spin);
    sphereGroup.rotateX(spin * 0.3);

    // per glyph updates
    for (const g of glyphs) {
      // state machine
      if (g.userData.state === "moment" && g.userData.targetPos) {
        g.userData.t = Math.min(1, g.userData.t + dt * 3.0);
        // ease
        const e = 1 - Math.pow(1 - g.userData.t, 3);
        // approach target in world space
        const pos = new THREE.Vector3().copy(g.position);
        pos.lerp(g.userData.targetPos, e);
        g.position.copy(pos);
        // face camera
        g.lookAt(camera.position);
        // slight scale up
        const s = g.userData.baseScale * (1.2 + 0.1 * Math.sin(now * 8 + g.userData.seed));
        g.scale.set(s, s, s);
      } else if (g.userData.state === "returning") {
        g.userData.t = Math.min(1, g.userData.t + dt * 1.6);
        const e = 1 - Math.pow(1 - g.userData.t, 2.2);
        const back = new THREE.Vector3().copy(g.position);
        back.lerp(g.userData.origPos, e);
        g.position.copy(back);
        if (g.userData.t >= 1) {
          g.userData.state = "free";
          g.userData.targetPos = null;
        }
      } else {
        // free: subtle drift around original position
        const off = driftOffset(g, now);
        const target = new THREE.Vector3().copy(g.userData.origPos).add(off);
        g.position.lerp(target, 0.08);
        // billboard to camera for legibility
        g.lookAt(camera.position);
        // slight distance-based scale (depth cue)
        const dist = g.position.distanceTo(camera.position);
        const s = g.userData.baseScale * THREE.MathUtils.clamp(32 / dist, 0.6, 1.6);
        g.scale.set(s, s, s);
        // gentle twinkle
        g.material.opacity = 0.8 + 0.2 * Math.sin(now * 2.0 + g.userData.seed);
      }
    }

    controls.update();
    renderer.render(scene, camera);

    // timed pareidolia
    if (sinceMoment >= MOMENT_EVERY) {
      sinceMoment = 0;
      triggerMoment();
    }

    requestAnimationFrame(tick);
  }

  // init
  populate(GLYPH_COUNT);
  tick();

  // === UI wiring ===
  const density = document.getElementById('density');
  const densityVal = document.getElementById('densityVal');
  const spin = document.getElementById('spin');
  const spinVal = document.getElementById('spinVal');
  const drift = document.getElementById('drift');
  const driftVal = document.getElementById('driftVal');
  const momentEvery = document.getElementById('momentEvery');
  const momentEveryVal = document.getElementById('momentEveryVal');
  const triggerBtn = document.getElementById('trigger');
  const shuffleBtn = document.getElementById('shuffle');

  density.addEventListener('input', e => {
    GLYPH_COUNT = +e.target.value;
    densityVal.textContent = GLYPH_COUNT;
    populate(GLYPH_COUNT);
  });
  spin.addEventListener('input', e => {
    GLOBAL_SPIN = +e.target.value;
    spinVal.textContent = (+GLOBAL_SPIN).toFixed(2);
  });
  drift.addEventListener('input', e => {
    MICRO_DRIFT = +e.target.value;
    driftVal.textContent = (+MICRO_DRIFT).toFixed(4);
  });
  momentEvery.addEventListener('input', e => {
    MOMENT_EVERY = +e.target.value;
    momentEveryVal.textContent = MOMENT_EVERY;
  });
  triggerBtn.addEventListener('click', () => triggerMoment());
  shuffleBtn.addEventListener('click', () => {
    // reassign random characters to all glyphs
    for (const g of glyphs) {
      const ch = ALL_CHARS[Math.floor(Math.random() * ALL_CHARS.length)];
      const tex = makeGlyphTexture(ch);
      g.material.map?.dispose();
      g.material.map = tex;
      g.material.needsUpdate = true;
      g.userData.char = ch;
    }
  });

  // resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // nice first moment after settle
  setTimeout(() => triggerMoment("FATE"), 1400);

})();
</script>
</body>
</html>
