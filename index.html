<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Breathing Sphere â€” Portrait TikTok</title>
<style>
  html, body { margin:0; background:#000; overflow:hidden; }
  #c { display:block; margin:0 auto; background:#000; }
  .ui {
    position:fixed; right:12px; bottom:12px; display:flex; gap:8px;
    font-family:system-ui, sans-serif; z-index:10;
  }
  button {
    background:#0c0c0c; color:#dff; border:1px solid #133; padding:10px 14px;
    border-radius:10px; cursor:pointer; font-weight:600; letter-spacing:.3px;
  }
  button:disabled { opacity:.6; cursor:not-allowed; }
</style>
</head>
<body>

<canvas id="c" width="1080" height="1920"></canvas>
<div class="ui">
  <button id="rec15">Record 15s</button>
  <button id="rec30">Record 30s</button>
</div>

<script>
/* ---------- Canvas setup ---------- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:false });
const W = 1080, H = 1920;

/* ---------- Assets (transparent) ---------- */
const sphereImg = new Image();        sphereImg.src = 'sphere_transparent.png?v=3';
const sphereBlinkImg = new Image();   sphereBlinkImg.src = 'sphere_blink_transparent.png?v=3';
const watermarkImg = new Image();     watermarkImg.src = 'sphere_transparent.png?v=3';
function dbg(msg){ console.log(msg); document.title = msg; }
sphereImg.onload = () => dbg('sphere OK');
sphereImg.onerror = () => dbg('sphere MISSING');

sphereBlinkImg.onload = () => dbg('blink OK');
sphereBlinkImg.onerror = () => dbg('blink MISSING');

watermarkImg.onload = () => dbg('wm OK');
watermarkImg.onerror = () => dbg('wm MISSING');

/* ---------- Visual params ---------- */
const teal = 'rgba(0,255,246,0.85)';
const red  = 'rgba(255,55,55,0.9)';
const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz0123456789';
const streams = [];
const STREAM_COUNT = 200;
const PULSE_PERIOD = 8_000;
let blinkActive = false;
let nextBlinkAt = scheduleBlink();
function scheduleBlink(){ return performance.now() + (90_000 + Math.random()*30_000); }

/* ---------- Text streams ---------- */
function newStream() {
  return {
    x: Math.random()*W,
    y: Math.random()*H,
    speed: 0.35 + Math.random()*0.8,
    ch: chars[Math.floor(Math.random()*chars.length)],
    color: Math.random()<0.02 ? red : teal,
    size: 14 + Math.random()*16,
    depth: 0.6 + Math.random()*0.8
  };
}
for (let i=0;i<STREAM_COUNT;i++) streams.push(newStream());

/* ---------- Audio (hum + chime + whisper) ---------- */
const AudioCtx = (() => {
  const ctx = new (window.AudioContext||window.webkitAudioContext)();

  const hum = ctx.createOscillator(); hum.type='sine'; hum.frequency.value=48;
  const humGain = ctx.createGain(); humGain.gain.value=0.04;
  hum.connect(humGain).connect(ctx.destination); hum.start();

  function chime() {
    const o = ctx.createOscillator(); o.type='sine'; o.frequency.value=640;
    const g = ctx.createGain(); g.gain.value=0.0001; o.connect(g).connect(ctx.destination);
    o.start();
    g.gain.linearRampToValueAtTime(0.08, ctx.currentTime+0.05);
    g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.8);
    o.stop(ctx.currentTime+0.85);
  }
  function whisper() {
    const o = ctx.createOscillator(); o.type='triangle'; o.frequency.value=210;
    const g = ctx.createGain(); g.gain.value=0.0001; o.connect(g).connect(ctx.destination);
    o.start();
    g.gain.linearRampToValueAtTime(0.02, ctx.currentTime+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.3);
    o.stop(ctx.currentTime+0.35);
  }
  return { ctx, chime, whisper };
})();

/* ---------- Draw loop ---------- */
function draw(now) {
  // Background
  ctx.fillStyle = "#000"; ctx.fillRect(0,0,W,H);

  // Streams (teal with occasional red whispers)
  streams.forEach(s => {
    ctx.fillStyle = s.color;
    ctx.font = `${s.size}px monospace`;
    ctx.fillText(s.ch, s.x, s.y);
    s.x += s.speed * s.depth;
    if (Math.random() < 0.004) {
      s.ch = chars[Math.floor(Math.random()*chars.length)];
      if (Math.random() < 0.02) { s.color = red; AudioCtx.whisper(); }
      else s.color = teal;
    }
    if (s.x > W + 30) { s.x = -40; s.y = Math.random()*H; }
  });

  // Breathing halo
  const phase = (now % PULSE_PERIOD) / PULSE_PERIOD;
  const cx = W/2, cy = H/2;
  const baseR = W * 0.22;
  const rScale = 1 + 0.1*Math.sin(phase * Math.PI*2);
  const grad = ctx.createRadialGradient(cx,cy, baseR*0.2, cx,cy, baseR*rScale);
  grad.addColorStop(0, 'rgba(0,255,246,0.24)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.arc(cx,cy, baseR*rScale, 0, Math.PI*2); ctx.fill();

  // Central sphere (transparent)
  const S = W * 0.34;
  const img = blinkActive ? sphereBlinkImg : sphereImg;
  const shimmer = 1 + 0.06*Math.sin(now/900);
  ctx.save();
  ctx.globalAlpha = 0.96;
  ctx.filter = `brightness(${shimmer})`;
  if (img.complete) ctx.drawImage(img, cx - S/2, cy - S/2, S, S);
  ctx.restore();

  // Subliminal watermark (bottom-left)
  if (watermarkImg.complete) {
    const wm = 90;                              // smaller
    const wmAlpha = 0.28 + 0.06*Math.sin(now/1100); // gentle shimmer, low opacity
    ctx.save();
    ctx.globalAlpha = wmAlpha;
    ctx.filter = 'brightness(1.2)';
    ctx.drawImage(watermarkImg, 20, H - wm - 24, wm, wm);
    ctx.restore();
  }

  // Chime at pulse peaks
  if (Math.abs(Math.sin(phase*Math.PI*2)) < 0.002 && (now - (AudioCtx._lastChime||0) > 1200)) {
    AudioCtx._lastChime = now; AudioCtx.chime();
  }

  // Rare blink
  if (!blinkActive && now >= nextBlinkAt) {
    blinkActive = true;
    setTimeout(()=>{ blinkActive = false; nextBlinkAt = scheduleBlink(); }, 150);
  }

  requestAnimationFrame(draw);
}
requestAnimationFrame(draw);

/* ---------- Recording buttons (WebM) ---------- */
async function record(seconds=15){
  const streamV = canvas.captureStream(30);
  const dest = AudioCtx.ctx.createMediaStreamDestination();
  const mixed = new MediaStream([...streamV.getVideoTracks(), ...dest.stream.getAudioTracks()]);
  const rec = new MediaRecorder(mixed, { mimeType:'video/webm;codecs=vp9,opus', videoBitsPerSecond: 6_000_000 });
  const chunks = [];
  rec.ondataavailable = e => e.data.size && chunks.push(e.data);
  rec.start();
  rec15.disabled = true; rec30.disabled = true;
  await new Promise(r => setTimeout(r, seconds*1000));
  rec.stop();
  await new Promise(r => rec.onstop = r);
  const blob = new Blob(chunks, {type:'video/webm'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url;
  a.download = `breathing_sphere_portrait_${seconds}s.webm`;
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  rec15.disabled = false; rec30.disabled = false;
}
const rec15 = document.getElementById('rec15');
const rec30 = document.getElementById('rec30');
rec15.onclick = ()=>record(15);
rec30.onclick = ()=>record(30);

// iOS audio unlock
window.addEventListener('pointerdown', () => {
  if (AudioCtx.ctx.state !== 'running') AudioCtx.ctx.resume();
}, { once:true });
</script>
</body>
</html>
